<?php

namespace ILIAS\UI\Implementation\Render;

use ILIAS\Refinery\Factory as Refinery;
use ILIAS\UI\Factory as RootFactory;
use ILIAS\UI\Component\Component;
use ILIAS\UI\Setup\ilUIBuildRendererMappingObjective;
use ilLanguage;

/**
 * Renderer loader using mappings generated by Composer
 *
 * @license Extended GPL, see docs/LICENSE
 * @copyright 1998-2020 ILIAS open source
 *
 * @author  Adrian Lüthi <al@studer-raimann.ch>
 */
class MappedRendererLoader implements Loader
{
    /**
     * @var array
     *
     * Mapping of ComponentClassname => RendererClassname
     * Classnames include Namespaces
     */
    private $mapping;

    /**
     * @var	RootFactory
     */
    protected $ui_factory;

    /**
     * @var	TemplateFactory
     */
    protected $tpl_factory;

    /**
     * @var	\ilLanguage
     */
    protected $lng;

    /**
     * @var	JavaScriptBinding
     */
    protected $js_binding;

    /**
     * @var Refinery
     */
    protected $refinery;

    public function __construct(
        RootFactory $ui_factory,
        TemplateFactory $tpl_factory,
        ilLanguage $lng,
        JavaScriptBinding $js_binding,
        Refinery $refinery)
    {
            $this->ui_factory = $ui_factory;
            $this->tpl_factory = $tpl_factory;
            $this->lng = $lng;
            $this->js_binding = $js_binding;
            $this->refinery = $refinery;

            $this->mapping = [];
            foreach (include ilUIBuildRendererMappingObjective::ARTIFACT_PATH as $component_class => $renderer_class) {
                $this->mapping[$component_class] = $renderer_class;
            }
    }

    /**
     * {@inheritDoc}
     * @see \ILIAS\UI\Implementation\Render\Loader::getRendererFor()
     */
    public function getRendererFor(Component $component, array $contexts) : ComponentRenderer
    {
        //@FABIAN context ist maximal dirty und wird daher ignoriert

        $component_class = get_class($component);

        //search by class
        if (array_key_exists($component_class, $this->mapping)) {
            return $this->createRenderer($this->mapping[$component_class]);
        }

        //search by interfaces
        foreach(class_implements($component_class) as $interface) {
            if (array_key_exists($interface, $this->mapping)) {
                $this->mapping[$component_class] = $this->mapping[$interface];
                return $this->createRenderer($this->mapping[$interface]);
            }
        }

        //search by parent classes
        while($component_class = get_parent_class($component_class)) {
            if (array_key_exists($component_class, $this->mapping)) {
                $this->mapping[$component_class] = $this->mapping[$component_class];
                return $this->createRenderer($this->mapping[$component_class]);
            }
        }

        throw new \Exception(sprintf('No renderer for class "%s" found.', get_class($component)));
    }

    /**
     * @param string $renderer_class
     * @return ComponentRenderer
     */
    private function createRenderer(string $renderer_class) : ComponentRenderer
    {
        return new $renderer_class(
            $this->ui_factory,
            $this->tpl_factory,
            $this->lng,
            $this->js_binding,
            $this->refinery
        );
    }

    /**
     * {@inheritDoc}
     * @see \ILIAS\UI\Implementation\Render\Loader::registerRenderer()
     */
    public function registerRenderer(string $renderer_class) : void
    {
        $renderer = $this->createRenderer($renderer_class);

        foreach ($renderer->getComponentInterfaceName() as $component_class) {
            $this->mapping[$component_class] = $renderer_class;
        }
    }

    /**
     * {@inheritDoc}
     * @see \ILIAS\UI\Implementation\Render\Loader::getRendererFactoryFor()
     */
    public function getRendererFactoryFor(Component $component)
    {
        //@FABIAN Theoretisch sollte diese klasse wohl eher die rendererfactory ersetzen,
        // aber ich sehe keinen grund für dies in zwei klassen zu trennen :P
    }
}